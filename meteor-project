#!/usr/bin/env bash
# Structured Meteor projects
# Tested on: Ubuntu 14.04 with
# GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)
# the name of this script
readonly script="$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")"
readonly version="0.3"
## Variables, Files - Directories
# project's name do not edit
PROJECT_NAME=""
# how many fixtures you want to creat for each collection
NUMBER_OF_FIXTURES=5
# an array for scaffolding fields
declare field_names
declare field_types
readonly ROOT_DIRECTORIES="client server lib collections public tests"
readonly CLIENT_DIRECTORIES="lib stylesheets views views/layout"
# files
readonly CLIENT_STYLESHEETS="client/stylesheets/style.css client/stylesheets/sticky_footer.css"

# additional .gitignore currently contains .idea directory
readonly GIT_IGNORE=".idea
*.sublime-project"

# Packages can be installed during project creation
# currenlty some defaults are bundled.
# Default packages can be edited, leave space for each package
PACKAGES=("iron:router" "mizzao:bootstrap-3")

## End of variables declarations ##
## File templates ##
# index.html template
INDEX="<template name=\"index\">
<h2>Home page content</h2>
<h3>I am the Index page, find me at client/views/index.html</h3>
</template>"

# main.html (iron router layout)
MAIN="<template name=\"main\">
<body>
{{> header}}
<!--bootstrap container class delete otherwise-->
<div class=\"container\">
{{> yield}}
</div>
{{> footer}}
</body>
</template>"

MAIN_HELPER="// This is the main template helper
// here you can handle some top level events,
// e.g: an event from the nav which may be global
Template.main.events ({

});

Template.main.helpers ({

});"

# head
HEAD="<head>
<title>${PROJECT_NAME}</title>
</head>"

# header.html
HEADER="<template name=\"header\">
    <!--bootstrap related classes delete otherwise-->
    <div class=\"navbar navbar-default navbar-fixed-top\" role=\"navigation\">
        <div class=\"container\">
            <div class=\"navbar-header\">
                <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">
                    <span class=\"sr-only\">Toggle navigation</span>
                    <span class=\"icon-bar\"></span>
                    <span class=\"icon-bar\"></span>
                    <span class=\"icon-bar\"></span>
                </button>
                <a class=\"navbar-brand\" >${PROJECT_NAME}</a>
            </div>
            <div class=\"collapse navbar-collapse\">
                <ul class=\"nav navbar-nav\">
                    <li class=\"active\"><a href=\"{{pathFor 'index'}}\">Home</a></li>
                    <li><a href=\"#about\">About</a></li>
                    <!--{{> loginButtons}} if accounts-password meteor package is used-->
                </ul>
            </div><!--/.nav-collapse -->
        </div>
    </div>
</template>"

FOOTER="<template name=\"footer\">
    <!--bootstrap footer classes delete otherwise-->
    <div class=\"footer\">
        <div class=\"container\">
            <p class=\"text-muted\">Place sticky footer content here.</p>
        </div>
    </div>
</template>"

STICKY_FOOTBAR="
/* Sticky footer styles
this file is used with Bootstrap 3 for the known sticky footer.
You can delete the file if Bootstrap 3 is not used or you do not want
a sticky footer.
-------------------------------------------------- */
html {
    position: relative;
    min-height: 100%;
}
body {
    /* Margin bottom by footer height */
    margin-bottom: 60px;
}
.footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    /* Set the fixed height of the footer here */
    height: 60px;
    background-color: #f5f5f5;
}


/* Custom page CSS
-------------------------------------------------- */
/* Not required for template or sticky footer method. */

body > .container {
    padding: 60px 15px 0;
}
.container .text-muted {
    margin: 20px 0;
}

.footer > .container {
    padding-right: 15px;
    padding-left: 15px;
}

code {
    font-size: 80%;
}"


# router.js basic contents
ROUTER="Router.configure({
  layoutTemplate: 'main'
});

Router.map(function () {

    this.route('index', {
        path: '/'
    });

});"

SUBSCRIPTIONS="//Meteor.subscribe('a_collection');"

SUBSCRIPTIONS="//Meteor.subscribe('a_collection');"

METHODS="//Meteor.methods({
    //
//});"

PUBLICATIONS="//Meteor.publish('a_collection', function(){
    //    return 'a_collection'.find();
    //});"

FIXTURES="//if (a_collection.find().count() === 0) {
    //
//}"

## End of template declarations ##
#
## Function declarations ##
#------------------------------------------------------------------------------#
# colored echo
# usage: colored "text" [color] [n for no new line]
# this function is taken from:
# http://stackoverflow.com/a/23006365/307826
function colored()
{
    local exp=$1;
    local color=$2;
    local newline=$3;
    if ! [[ $color =~ ^[0-9]$ ]] ; then
       case $(echo "${color}" | tr '[:upper:]' '[:lower:]') in
        black) color=0 ;;
        red) color=1 ;;
        green) color=2 ;;
        yellow) color=3 ;;
        blue) color=4 ;;
        magenta) color=5 ;;
        cyan) color=6 ;;
        white|*) color=7 ;; # white or invalid color
       esac
    fi
    tput setaf $color;
    # if third arg is n then print and do not change line
    if [[ ${newline} = "n" ]]; then
        echo -n "${exp}";
    else
        echo "${exp}";
    fi
    tput sgr0;
}
#------------------------------------------------------------------------------#
# prints script's version and help message
# params: optional one of the available commands to print specific to the command
#         help
function help
{
    colored "--------------------------------------------------------------------------------" blue
    if [[ ! -z $1 ]]; then
        if [[ $1 = "project" ]]; then
            colored "$1 command " white n
            colored "creates a new Meteor project" magenta
            colored "Usage: \$${script} project [PROJECT_NAME]" cyan
        elif [[ $1 = "new" ]]; then
            colored "$1 command " white n
            colored "generates a view or collection" magenta
            colored "type: \$${script} new view or \$${script} new collection" cyan
        elif [[ $1 = "new view" ]]; then
            colored "$1 command " white n
            colored "generates a new view (a template, a helper and a route)" magenta
            colored "Usage: \$${script} new view [VIEW_NAME]" cyan
        elif [[ $1 = "new collection" ]]; then
            colored "$1 command " white n
            colored "generates a new collection" magenta
            colored "Usage: \$${script} new collection [COLLECTION_NAME]" cyan
        elif [[ $1 = "scaffold" ]]; then
            colored "$1 command " white n
            colored "generates a new collection, a fixture, a view, an edit view & their helpers" magenta
            colored "Usage: \$${script} scaffold [COLLECTION_NAME] [FIELD:TYPE] [FIELD:TYPE] ..." cyan
            colored "Available fields: string, text, number, date and boolean" cyan
        fi
    else
        colored "${script} version: ${version}"
        colored "A script to create Meteor projects, views, collections and scaffolds"
        colored "Available commands: project, new view, new collection, scaffold" magenta
    fi
    colored "--------------------------------------------------------------------------------" blue
}
#------------------------------------------------------------------------------#
# checks user input and invokes the respective generator(s)
function user_input
{
    # collect user input

    # Empty args
    if [[ -z "$1" ]]; then
        colored "Error: command is missing" red
        help "$@"
    # project creation
    elif [[ "$1" = "project" ]]; then
        if [[ -z "$2" ]]; then
            colored "Error: project name is missing" red
            colored "Usage: \$${script} project [project_name] or" cyan
            colored "project \$${script} [project_name] packages [package_name] [package_name] ..." cyan
        else
            eval PROJECT_NAME="$2"

            create_project

            create_project_root_dirs

            create_project_root_files

            create_client_dirs

            create_client_files

            create_server_files
            # check for additional packages
            if [[ "${#}" -gt 3 ]]; then
                for package in "${@:4}"; do
                    PACKAGES=("${PACKAGES[@]}" " ${package}")
                done
            fi
            install_packages

            colored "cd into project ${PROJECT_NAME} to start working" yellow
        fi
    elif [[ "$1" = "new" ]]; then
                if [[ -z "$2" ]]; then
                    colored "Error: generator name is missing" red
                    help "$1"

                elif [[ "$2" = "view" ]]; then
                    if [[ -z "$3" ]]; then
                        colored "Error: view name is missing" red
                        help "new view"
                    else
                        create_view "$3"
                    fi

                elif [[ "$2" = "collection" ]]; then
                    if [[ -z "$3" ]]; then
                        colored "Error: collection name is missing" red
                        help "new collection"
                    else
                        create_collection "$3"
                        create_fixture "$3"
                    fi

                else
                    colored "Error unknown generator" red
                    help "$1"
                fi
    elif [[ "$1" = "scaffold" ]]; then
        # check for collection name and a valid array of fields:types
        if [[ ! -z "$2" ]]; then
            # pass arguments after the collection name
            args="${@:3}"
            if fields_pairs_are_valid "${args}"; then
                if field_types_are_valid "${args}";then
                    pack_fields "${args}"
                    # start scaffolding
                    do_scaffold "$2"
                else
                    colored "Error: wrong types provided" red
                    help "scaffold"
                fi
            else
                colored "Error: wrong key:value pairs" red
                help "scaffold"
            fi
        else
            colored "Error: collection (model) name is missing" red
            help "scaffold"
        fi

    else
        colored "Error unknown command" red
        help ""
    fi
}
#------------------------------------------------------------------------------#
# checks if for all passed fields there is a respective type
# params: an array/string of fields:types [field1:type field2:type, ...]
# returns: true if array contains pairs only, false otherwise
function fields_pairs_are_valid
{
    old_ifs=$IFS
    IFS=" "
    item_number=""
    for pair in $1; do
        pair_number=$(( pair_number + 1 ))
        IFS=":"
        for item in ${pair[*]}; do
            item_number=$(( item_number + 1 ))
        done
    done
    if [ "$(( ${item_number} % 2 ))" -eq 0 ] ; then
        IFS=$old_ifs
        return 0
    else
        IFS=$old_ifs
        return 1
    fi

    IFS=$old_ifs
}
#------------------------------------------------------------------------------#
# check if all passed types for a scaffold are valid
# params: an array/string of field:type pairs
# remarks: available types are: string, text, number, date
function field_types_are_valid
{
    old_ifs=$IFS
    IFS=" "
    result=0

    for pair in $1; do
        IFS=":"
        index=0
        for item in ${pair};do
            index=$(( index + 1 ))
            if (( index == 2 )); then
                case "${item}" in
                    "string" )
                        break;;
                    "text" )
                        break;;
                    "number" )
                        break;;
                    "date" )
                        break;;
                    "boolean" )
                        break;;
                    # if nothing matched return error
                    * )
                        result=1
                esac
            fi
        done
    done

    return ${result}
    IFS=$old_ifs
}
#------------------------------------------------------------------------------#
# separates field names and types and saves them into
# the field_names and field_types arrays
# params: an array/string of field:type pairs
function pack_fields
{
    old_ifs=$IFS
    IFS=" "
    for pair in $1; do
        IFS=":"
        index=0
        for item in ${pair};do
            index=$(( index + 1 ))
            if (( index == 1 )); then
                field_names+=( "${item}" )
            else
                field_types+=( "${item}" )
            fi
        done
    done

    IFS=$old_ifs
}
#------------------------------------------------------------------------------#
# creates a Meteor project
function create_project
{
    echo "Creating project: ${PROJECT_NAME}"
    # create project
    meteor create "${PROJECT_NAME}" >/dev/null

    cd "${PROJECT_NAME}"
    # delete default generated files
    rm "${PROJECT_NAME}".*

    colored "Project ${PROJECT_NAME} has been created" green
}
#------------------------------------------------------------------------------#
# installs Meteor packages
function install_packages
{
    if [[ -n "${PACKAGES[*]}" ]]; then
        echo "Installing packages:"
        colored "${PACKAGES[*]}" yellow
        for package in ${PACKAGES[*]}; do
            meteor add "${package}"
        done
        colored "${#PACKAGES[@]} packages have been installed" green
    fi
}
#------------------------------------------------------------------------------#
# creates project's root directories
function create_project_root_dirs
{
    # project's root directories
    echo "Creating root directories"
    for directory in ${ROOT_DIRECTORIES}; do
        mkdir "${directory}"
    done
    colored "Project's root directories have been created" green
}

#------------------------------------------------------------------------------#
# creates project's root files
function create_project_root_files
{
    echo "Creating root various files"
    # additonal top level gitignore for editors - IDEs
    echo "${GIT_IGNORE}" > .gitignore

    echo "${ROUTER}" > "lib/router.js"

    colored "All root files have been created" green
}
#------------------------------------------------------------------------------#
# creates client's directory structure
function create_client_dirs
{
    echo "Creating client's directory structure"
    for directory in ${CLIENT_DIRECTORIES};do
        mkdir "client/${directory}"
    done
    colored "Client's directory structure have been created" green
}
#------------------------------------------------------------------------------#
# creates client's files
function create_client_files
{
    echo "Creating client files"
    echo "${INDEX}" > "client/views/index.html"
    echo "${MAIN}" > "client/views/layout/main.html"
    echo "${HEADER}" > "client/views/layout/header.html"
    echo "${FOOTER}" > "client/views/layout/footer.html"
    echo "${HEAD}" > "client/views/layout/head.html"

    for file in ${CLIENT_STYLESHEETS};do
        touch "${file}"
    done

    echo "${STICKY_FOOTBAR}" > "client/stylesheets/sticky_footer.css"
    echo "${SUBSCRIPTIONS}" > "client/lib/subscriptions.js"
    echo "${MAIN_HELPER}" > "client/views/layout/main.js"

    colored "All client's files have been created" green
}
#------------------------------------------------------------------------------#
# creates server's files
function create_server_files
{
    echo "Creating server files"
    echo "${METHODS}" > "server/methods.js"
    echo "${PUBLICATIONS}" > "server/publications.js"
    echo "${FIXTURES}" > "server/fixtures.js"
    colored "All server files have been created" green
}
#------------------------------------------------------------------------------#
# check if this script is invoked from a valid Meteor project root
# by checking if .meteor directory exists
# returns: true if in a valid project root, false otherwise
function in_project_dir
{
    if [[ -d ".meteor" ]]; then
        return 0
    else
        return 1
    fi
}
#------------------------------------------------------------------------------#
# checks if a file exists
# returns: true if file exists, false otherwise
function dir_exists
{
    if [[ -d "$1" ]]; then
        return 0
    else
        return 1
    fi
}
#------------------------------------------------------------------------------#
function file_exists
{
    if [[ -f "$1" ]]; then
        return 0
    else
        return 1
    fi
}
#------------------------------------------------------------------------------#
# check if a directory is empty
# params: directory path
# returns: true if is empty, false otherwise
function dir_is_empty
{
    if [[ -z $1 ]]; then
        if find $1 -mindepth 1 -print -quit | grep -q .; then
            return 0
        else
            return 1
        fi
    fi
}
#------------------------------------------------------------------------------#
# Creates a new collection
# params: collection's name
function create_collection
{
    if in_project_dir; then
        if [[ -z "$1" ]]; then
            colored "Error: collection name is missing" red
            colored "Usage: \$${script} new model [model name]" cyan
        else
            if file_exists "collections/$1.js";then
                colored "The collection $1 allready exists!" yellow
            else
                tpl="$1 = new Meteor.Collection('$1');"

                echo "${tpl}" > "collections/$1.js"

                colored "The collection $1 has been created at collections/$1.js" green
            fi
        fi
    else
        colored "Error: not valid Meteor project directory" red
        colored "This command must be called from project's root directory" cyan
    fi
}
#------------------------------------------------------------------------------#
# creates a fixture for a given collection
# params: collection's name
#       : keyword scaffold (optional)
# remarks: if scaffold keyword is given then the
#          function looks the fields array to get
#          all available field names and types
function create_fixture
{
    # generate NUMBER_OF_FIXTURES
    tpl="if ($(basename "$1").find().count() === 0) {
    for (var i=0; i < ${NUMBER_OF_FIXTURES}; i++) {
        $(basename "$1").insert({"

    tpl_end="
        });
    }
}"

    tpl_mid=""
    if [[ "$2" = "scaffold" ]]; then
            for (( j = 0; j < ${#field_names[*]}; j++ )); do
                # generate a field value according to it's type
                local val
                if [[ ${field_types[j]} = "number" ]]; then
                    val="i"
                elif [[ ${field_types[j]} = "string" ]]; then
                    val="'short string ' + i"
                elif [[ ${field_types[j]} = "text" ]]; then
                    val="'this is a long text ' + i"
                elif [[ ${field_types[j]} = "date" ]]; then
                    val=\'$(date "+%b-%d-%Y")\'
                elif [[ ${field_types[j]} = "boolean" ]]; then
                    val="true"
                fi
                tpl_mid+="
            ${field_names[j]}: ${val}"
                # add comma to collection field if needed
                if (( j+1 < ${#field_names[*]} )); then
                    tpl_mid+=","
                fi
            done
    # if not called during a scaffold create a simpler version
    else
        tpl_mid="
            $(basename "$1"): '$(basename "$1") ' + i"
    fi

    tpl+="${tpl_mid}${tpl_end}"
    echo "" >> "server/fixtures.js"
    echo "${tpl}" >> "server/fixtures.js"
}
#------------------------------------------------------------------------------#
# Creates a new template
# params: template's name
function create_template
{
    if in_project_dir; then
        if [[ -z "$1" ]]; then
            colored "Error: template name is missing" red
            colored "Usage: \$${script} new template [template name]" cyan
        else
            if file_exists "client/views/$1/$1.html";then
                colored "The template $1 allready exists." yellow
            else
                tpl="<template name=\"$(basename $1)\">
<h3>{{name}}</h3>
</template>"
                # deep directory tree
                echo "${tpl}" > "client/views/$1/$(basename $1).html"

                colored "The template $1 has been created at 'client/views/$1/$(basename $1).html'" green
            fi
        fi
    else
        colored "Error: not valid Meteor project directory" red
        colored "This command must be called from project's root directory" cyan
    fi
}
#------------------------------------------------------------------------------#
# Creates a new helper
# params: helper's name
function create_helper
{
    if in_project_dir; then
        if [[ -z "$1" ]]; then
            colored "Error: helper name is missing" red
            colored "Usage: \$${script} new helper [helper name] <-- must match with a view name" cyan
        else
            if file_exists "client/views/$1/$1.js";then
                colored "The helper $1 allready exists" yellow
            else

                tpl="Template.$(basename $1).helpers ({

    // controllers
    name: function() {
        return 'This is $(basename $1) template, find me at client/views/$1'
    }

});

Template.$(basename $1).events ({

    // event handlers
    'click #id': function() {
        //
    }

});
"                echo "${tpl}" > "client/views/$1/$(basename $1).js"
                colored "The template $1 has been created at client/views/$1/$(basename $1).js" green
            fi
        fi
    else
        colored "Error: not valid Meteor project directory" red
        colored "This command must be called from project's root directory" cyan
    fi
}
#------------------------------------------------------------------------------#
# Adds a new route into router.js
# params: view's name
#       : scaffold (just the word)
function add_route
{
    if [[ -z $1 ]]; then
        # do nothing for now
        :
    else
        # if is a simple view creation
        tpl="\\    this.route('$(basename $1)', { \\
        path: '/$1/' \\
    });"

        # use sed to append after the pattern
        pattern="Router.map"

        sed -i "/$pattern/a $tpl\ " "lib/router.js"
        sed -i "/$pattern/a \ " "lib/router.js"

        # is used for scaffolding
            if [[ -z $2 ]] && [[ $2 = "scaffold" ]]; then

            tpl_edit="\\    this.route('edit_$(basename $1)', { \\
        path: '/$1/edit/' \\
    });"

            sed -i "/$pattern/a $tpl_edit\ " "lib/router.js"
            sed -i "/$pattern/a \ " "lib/router.js"
        fi
    fi
}
#------------------------------------------------------------------------------#
# Creates a combination of a template and a helper
# params: view's name
function create_view
{
    if in_project_dir; then
        if [[ -z $1 ]]; then
            colored "Error: view name is missing" red
            colored "Usage: \$${script} new [view name]" cyan
        else
            if dir_exists "client/views/$1";then
                colored "The view $1 allready exists! Overwrite? [Yy]es, [Nn]o: " yellow n
                while [[ : ]]; do
                    read option
                    if [[ ${option} =~ ^(yes|y|Y|Yes|YES|yES|yeS)$ ]]; then
                            mkdir -p "client/views/$1"
                            create_template "$1"
                            create_helper "$1"
                            add_route "$1"
                            colored "The view $1 has been created at client/views/$1" green
                            colored "and registered as route /$1" green
                        exit;
                    elif [[ ${option} =~ ^(no|n|N|No|NO)$ ]]; then
                        exit;
                    else
                        colored "Please select either Yes, yes or No, no: " red n
                    fi
                done
            else
                mkdir -p "client/views/$1"
                create_template "$1"
                create_helper "$1"
                add_route "$1"
                colored "The view $1 has been created at client/views/$1" green
                colored "and registered as route /$1/" green
            fi
        fi
    else
        colored "Error: not valid Meteor project directory" red
        colored "This command must be called from project's root directory" cyan
    fi
}
#------------------------------------------------------------------------------#
# creates a collection, view and edit templates with their helpers
# their routes and fixtures
# params: model's name which is the same as the view's name
#       : fields names:types
# example: do_scaffold blogpost title:text created:datetime posted:boolean
function do_scaffold
{
    if in_project_dir; then
        if [[ -z $1 ]]; then
            colored "Error: view name is missing" red
            colored "Usage: \$${script} new [view name]" cyan
        else
            if dir_exists "client/views/$1";then
                colored "The view $1 allready exists! Overwrite? [Yy]es, [Nn]o: " yellow n
                while [[ : ]]; do
                    read option
                    if [[ ${option} =~ ^(yes|y|Y|Yes|YES|yES|yeS)$ ]]; then
                            mkdir -p "client/views/$1"
                            create_template "$1"
                            create_helper "$1"
                            add_route "$1"
                            colored "The view $1 has been created at client/views/$1" green
                            colored "and registered as route /$1" green
                        exit;
                    elif [[ ${option} =~ ^(no|n|N|No|NO)$ ]]; then
                        exit;
                    else
                        colored "Please select either Yes, yes or No, no: " red n
                    fi
                done
            else
                # scaffold here
                create_collection "$1" > /dev/null
                add_route
                create_fixture "$1" "scaffold"
                colored "The scaffold for $1 has been created at client/views/$1" green
            fi
        fi
    else
        colored "Error: not valid Meteor project directory" red
        colored "This command must be called from project's root directory" cyan
    fi
}
#------------------------------------------------------------------------------#
function main
{
    user_input "$@"
}

## End of functions declarations ##
#------------------------------------------------------------------------------#
# invoke the main function
main "$@"
